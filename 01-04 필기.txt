 * 하둡하면 머리속에 기억하고 있어야할 큰 내용

1. NoSQL : (1) hive   -----------> big data (의료용 데이터, 갤럭시 7 핸드폰의 로그데이터
	   (2) Tajo                          sns에 올리는 글들 )
	   (3) pig
	   (4) mongodb

2. RDBMS : (1) Oracle  ----------> business data ( small data )
	   (2) MySQL




문제 128. 오늘의 무슨요일인지 출력하시오 !
 
	SQL> select to_char ( sysdate, 'day' )
	       from dual;
	
	
	mysql> select date_format( sysdate(), '%W' )
	    ->   from dual;
	+--------------------------------+
	| date_format( sysdate(), '%W' ) |
	+--------------------------------+
	| Friday                         |
	+--------------------------------+
	1 row in set (0.00 sec)



문제 129. 이름, 입사일, 입사한 요일을 출력하시오 !

	SQL> select ename, hiredate, to_char( hiredate, 'day')
	       from emp;
	
	mysql> select ename, hiredate, date_format(hiredate,'%w')
	    -> from emp;
	+--------+------------+------------------------------+
	| ename  | hiredate   | date_format( hiredate, '%W') |
	+--------+------------+------------------------------+
	| KING   | 1981-11-17 | Tuesday                      |
	| BLAKE  | 1981-05-01 | Friday                       |
	| CLARK  | 1981-05-09 | Saturday                     |
	| JONES  | 1981-04-01 | Wednesday                    |
	| MARTIN | 1981-09-10 | Thursday                     |
	| ALLEN  | 1981-02-11 | Wednesday                    |
	| TURNER | 1981-08-21 | Friday                       |
	| JAMES  | 1981-12-11 | Friday                       |
	| WARD   | 1981-02-23 | Monday                       |
	| FORD   | 1981-12-11 | Friday                       |
	| SMITH  | 1980-12-09 | Tuesday                      |
	| SCOTT  | 1982-12-22 | Wednesday                    |
	| ADAMS  | 1983-01-15 | Saturday                     |
	| MILLER | 1982-01-11 | Monday                       |
	+--------+------------+------------------------------+
	14 rows in set (0.00 sec)



★ Oracle vs MySQL의 차이를 총정리

		oracle		vs		MySQL
	1. nvl					ifnull
	2. sysdate				sysdate()
	3. months_between			period_diff
	4. add_months				period_add
	5. last_day				last_day
	6. to_char				format
	7. decode				if
	8. case					case
	9. rollup				with rollup
	10. rank, dense rank			지원안함



문제 130. 이름과 월급을 출력하는데 월급을 출력할때에 천단위를 붙이시오 !

	SQL> select ename, to_char(sal, '999,999')
	       from emp;
	
	mysql> select ename, format(sal, 0)
	    ->   from emp;
	+--------+----------------+
	| ename  | format(sal, 0) |
	+--------+----------------+
	| KING   | 5,000          |
	| BLAKE  | 2,850          |
	| CLARK  | 2,450          |
	| JONES  | 2,975          |
	| MARTIN | 1,250          |
	| ALLEN  | 1,600          |
	| TURNER | 1,500          |
	| JAMES  | 950            |
	| WARD   | 1,250          |
	| FORD   | 3,000          |
	| SMITH  | 800            |
	| SCOTT  | 3,000          |
	| ADAMS  | 1,100          |
	| MILLER | 1,300          |
	+--------+----------------+
	14 rows in set (0.00 sec)



문제 131. 이름, 직업, 보너스를 출력하는데 직업이 SALESMAN 이면 보너스를 6000을 출력하고 아니면 0을 출력하시오 !

	SQL> select ename, job, decode(job, 'SALESMAN', 6000, 0) as bonus
	       from emp;
	
	mysql> select ename, job, if(job='salesman', 6000, 0) as bonus
	    ->   from emp;
	+--------+-----------+-------+
	| ename  | job       | bonus |
	+--------+-----------+-------+
	| KING   | PRESIDENT |     0 |
	| BLAKE  | MANAGER   |     0 |
	| CLARK  | MANAGER   |     0 |
	| JONES  | MANAGER   |     0 |
	| MARTIN | SALESMAN  |  6000 |
	| ALLEN  | SALESMAN  |  6000 |
	| TURNER | SALESMAN  |  6000 |
	| JAMES  | CLERK     |     0 |
	| WARD   | SALESMAN  |  6000 |
	| FORD   | ANALYST   |     0 |
	| SMITH  | CLERK     |     0 |
	| SCOTT  | ANALYST   |     0 |
	| ADAMS  | CLERK     |     0 |
	| MILLER | CLERK     |     0 |
	+--------+-----------+-------+
	14 rows in set (0.00 sec)



문제 132. 이름, 직업, 보너스를 출력하는데 직업이 SALESMAN이면 보너스를 6000을 출력하고 직업이 ANALYST이면
	  보너스를 3000을 출력하고 나머지는 0을 출력하시오 !

	SQL> select ename, job, decode( job, 'SALESMAN', 6000, job, 'ANALYST', 3000, 0 ) as bonus
	       from emp;
	
	mysql> select ename, job, if ( job='salesman', 6000, if(job='analyst', 3000, 0)) as bonus
	    ->   from emp;
	+--------+-----------+-------+
	| ename  | job       | bonus |
	+--------+-----------+-------+
	| KING   | PRESIDENT |     0 |
	| BLAKE  | MANAGER   |     0 |
	| CLARK  | MANAGER   |     0 |
	| JONES  | MANAGER   |     0 |
	| MARTIN | SALESMAN  |  6000 |
	| ALLEN  | SALESMAN  |  6000 |
	| TURNER | SALESMAN  |  6000 |
	| JAMES  | CLERK     |     0 |
	| WARD   | SALESMAN  |  6000 |
	| FORD   | ANALYST   |  3000 |
	| SMITH  | CLERK     |     0 |
	| SCOTT  | ANALYST   |  3000 |
	| ADAMS  | CLERK     |     0 |
	| MILLER | CLERK     |     0 |
	+--------+-----------+-------+
	14 rows in set (0.00 sec)



문제 133. 이름, 부서번호, 보너스를 출력하는데 부서번호가 10번이면 보너스를 7000으로, 부서번호가 20번이면
	  9000으로, 부서번호가 30번이면 보너스를 4000으로 출력하시오 !

	SQL> select ename, deptno,
	            case deptno when 10 then 6000
	                        when 20 then 9000
	            else 4000
	            end as bones
	       from emp;
	
	mysql> select ename, deptno,
	    ->             case deptno when 10 then 6000
	    ->                         when 20 then 9000
	    ->             else 4000
	    ->             end as bones
	    ->        from emp;
	+--------+--------+-------+
	| ename  | deptno | bones |
	+--------+--------+-------+
	| KING   |     10 |  6000 |
	| BLAKE  |     30 |  4000 |
	| CLARK  |     10 |  6000 |
	| JONES  |     20 |  9000 |
	| MARTIN |     30 |  4000 |
	| ALLEN  |     30 |  4000 |
	| TURNER |     30 |  4000 |
	| JAMES  |     30 |  4000 |
	| WARD   |     30 |  4000 |
	| FORD   |     20 |  9000 |
	| SMITH  |     20 |  9000 |
	| SCOTT  |     20 |  9000 |
	| ADAMS  |     20 |  9000 |
	| MILLER |     10 |  6000 |
	+--------+--------+-------+
	14 rows in set (0.17 sec)



문제 134. 이름, 월급, 보너스를 출력하는데 월급이 2000 이상이면 보너스를 900을 출력하고 1000이상이면 보너스를
	  800을 출력하고 나머지는 0을 출력하시오 

	SQL>
	select ename, sal,
	       case when sal >= 2000 then 900
	            when sal >= 1000 then 800
	       else 0 end as bonus 
	  from emp;
	
	mysql> select ename, sal,
	    ->        case when sal >= 2000 then 900
	    ->             when sal >= 1000 then 800
	    ->        else 0 end as bonus
	    ->   from emp;
	+--------+------+-------+
	| ename  | sal  | bonus |
	+--------+------+-------+
	| KING   | 5000 |   900 |
	| BLAKE  | 2850 |   900 |
	| CLARK  | 2450 |   900 |
	| JONES  | 2975 |   900 |
	| MARTIN | 1250 |   800 |
	| ALLEN  | 1600 |   800 |
	| TURNER | 1500 |   800 |
	| JAMES  |  950 |     0 |
	| WARD   | 1250 |   800 |
	| FORD   | 3000 |   900 |
	| SMITH  |  800 |     0 |
	| SCOTT  | 3000 |   900 |
	| ADAMS  | 1100 |   800 |
	| MILLER | 1300 |   800 |
	+--------+------+-------+
	14 rows in set (0.00 sec)



문제 135. 아래와 같이 결과를 출력하시오 !

	SQL> select sum ( decode ( deptno, 10, sal, null ) ) as 10,
	            sum ( decode ( deptno, 20, sal, null ) ) as 20,
	            sum ( decode ( deptno, 30, sal, null ) ) as 30
	       from emp;
	
	mysql> select sum( if( deptno = 10 , sal, null ) ) as "10",
	    ->        sum( if( deptno = 20 , sal, null ) ) as "20",
	    ->        sum( if( deptno = 30 , sal, null ) ) as "30"
	    ->   from emp;
	+------+-------+------+
	| 10   | 20    | 30   |
	+------+-------+------+
	| 8750 | 10875 | 9400 |
	+------+-------+------+
	1 row in set (0.00 sec)



문제 136. 아래의 SQL을 MySQL로 구현하시오 !

	SQL> select deptno, sum(sal)
	       from emp
	       group by rollup(deptno);
	
	mysql> select deptno, sum(sal)
	    ->   from emp
	    ->   group by deptno with rollup;
	+--------+----------+
	| deptno | sum(sal) |
	+--------+----------+
	|     10 |     8750 |
	|     20 |    10875 |
	|     30 |     9400 |
	|   NULL |    29025 |
	+--------+----------+
	4 rows in set (0.02 sec)

		※ MySQL은 rollup은 with rollup으로 지원하는데 cube는 지원하지 않는다.



문제 137. 아래의 SQL을 MySQL로 구현하시오 !

	SQL> select deptno, sum(sal)
	       from emp
	       group by cube(deptno);
	
	mysql> select null as deptno, sum(sal)
	    ->   from emp
	    -> union all
	    -> select deptno, sum(sal)
	    ->   from emp
	    ->   group by deptno;
	+--------+----------+
	| deptno | sum(sal) |
	+--------+----------+
	|   NULL |    29025 |
	|     10 |     8750 |
	|     20 |    10875 |
	|     30 |     9400 |
	+--------+----------+
	4 rows in set (0.04 sec)



문제 138. 이름, 입사일, 순위를 출력하는데 순위가 먼저 입사한 사원순으로 순위를 부여하시오 !

	SQL> select ename, hiredate, rank() over (order by hiredate asc) 순위
	       from emp;
	
	mysql> select ename, hiredate, (select count(*) + 1 from emp where hiredate < e.hiredate ) 순위
	    ->   from emp e
	    ->   order by hiredate asc;
	+--------+------------+--------+
	| ename  | hiredate   | 순위   |
	+--------+------------+--------+
	| SMITH  | 1980-12-09 |      1 |
	| ALLEN  | 1981-02-11 |      2 |
	| WARD   | 1981-02-23 |      3 |
	| JONES  | 1981-04-01 |      4 |
	| BLAKE  | 1981-05-01 |      5 |
	| CLARK  | 1981-05-09 |      6 |
	| TURNER | 1981-08-21 |      7 |
	| MARTIN | 1981-09-10 |      8 |
	| KING   | 1981-11-17 |      9 |
	| FORD   | 1981-12-11 |     10 |
	| JAMES  | 1981-12-11 |     10 |
	| MILLER | 1982-01-11 |     12 |
	| SCOTT  | 1982-12-22 |     13 |
	| ADAMS  | 1983-01-15 |     14 |
	+--------+------------+--------+
	14 rows in set (0.00 sec)



문제 139. 이름, 월급, 순위를 출력하시오 ! (순위는 월급 높은 순)

	SQL> select ename, sal, rank() over (order by sal desc)
	       from emp;
	
	mysql> select ename, sal, (select count(*) + 1 from emp where sal > e.sal) 순위
	    ->   from emp e
	    ->   order by sal desc;
	+--------+------+--------+
	| ename  | sal  | 순위   |
	+--------+------+--------+
	| KING   | 5000 |      1 |
	| SCOTT  | 3000 |      2 |
	| FORD   | 3000 |      2 |
	| JONES  | 2975 |      4 |
	| BLAKE  | 2850 |      5 |
	| CLARK  | 2450 |      6 |
	| ALLEN  | 1600 |      7 |
	| TURNER | 1500 |      8 |
	| MILLER | 1300 |      9 |
	| WARD   | 1250 |     10 |
	| MARTIN | 1250 |     10 |
	| ADAMS  | 1100 |     12 |
	| JAMES  |  950 |     13 |
	| SMITH  |  800 |     14 |
	+--------+------+--------+
	14 rows in set (0.00 sec)



문제 140. 부서번호, 이름, 월급, 순위를 출력하는데 순위가 부서번호별로 각각 월급이 높은 순서대로 순위를
	  출력하시오 !

SQL> select deptno, ename, sal, rank() over (partition by deptno order by sal desc)
       from emp;


	mysql> select deptno, ename, sal, 
	    ->        (select count(*) + 1 from emp where sal > e.sal and deptno = e.deptno) 순	위
	    ->   from emp e
	    ->   order by deptno, sal desc;
	+--------+--------+------+--------+
	| deptno | ename  | sal  | 순위   |
	+--------+--------+------+--------+
	|     10 | KING   | 5000 |      1 |
	|     10 | CLARK  | 2450 |      2 |
	|     10 | MILLER | 1300 |      3 |
	|     20 | SCOTT  | 3000 |      1 |
	|     20 | FORD   | 3000 |      1 |
	|     20 | JONES  | 2975 |      3 |
	|     20 | ADAMS  | 1100 |      4 |
	|     20 | SMITH  |  800 |      5 |
	|     30 | BLAKE  | 2850 |      1 |
	|     30 | ALLEN  | 1600 |      2 |
	|     30 | TURNER | 1500 |      3 |
	|     30 | WARD   | 1250 |      4 |
	|     30 | MARTIN | 1250 |      4 |
	|     30 | JAMES  |  950 |      6 |
	+--------+--------+------+--------+
	14 rows in set (0.00 sec)



문제 141. 부서번호, 해당 부서번호에 속한 사원들의 이름을 가로로 출력하시오 !

	SQL> select deptno, listagg(ename, ',') within group (order by ename asc) ename
	       from emp
	       group by deptno;
	
	mysql> select deptno, group_concat(ename order by ename asc separator ',')
	    ->   from emp
	    ->   group by deptno;
	+--------+------------------------------------------------------+
	| deptno | group_concat(ename order by ename asc separator ',') |
	+--------+------------------------------------------------------+
	|     10 | CLARK,KING,MILLER                                    |
	|     20 | ADAMS,FORD,JONES,SCOTT,SMITH                         |
	|     30 | ALLEN,BLAKE,JAMES,MARTIN,TURNER,WARD                 |
	+--------+------------------------------------------------------+
	3 rows in set (0.00 sec)



문제 142. 아래와 같이 결과를 출력하시오 !

	+--------+-------------------------------------------------------------------------+
	| deptno | group_concat(enamesal order by ename asc separator ',')                 |
	+--------+-------------------------------------------------------------------------+
	|     10 | CLARK(2450),KING(5000),MILLER(1300)                                     |
	|     20 | ADAMS(1100),FORD(3000),JONES(2975),SCOTT(3000),SMITH(800)               |
	|     30 | ALLEN(1600),BLAKE(2850),JAMES(950),MARTIN(1250),TURNER(1500),WARD(1250) |
	+--------+-------------------------------------------------------------------------+
	3 rows in set (0.00 sec)
	
		mysql> select deptno, group_concat(enamesal order by ename asc separator ',')
		    ->   from (select deptno, ename, concat( ename, '(', sal, ')') as enamesal
		    ->           from emp) ee
		    ->   group by deptno;



문제 143. 이름과 부서위치를 출력하시오 ! (MySQL에서는 1999ansi 문법으로 수행한다 )

	※ MySQL 에서의 조인은 1999 ansi 문법으로 수행한다
	
	select ename, loc
	  from emp e join dept d
	  on ( e.deptno = d.deptno);



문제 144. 아래의 오라클 조인문장을 MySQL에서 구현하시오 !

	SQL> select e.ename, d.loc
	       from emp e, dept d 
	       where e.deptno (+) = d.deptno;
	
	mysql> select e.ename, d.loc
	    ->   from emp e right outer join dept d
	    ->   on ( e.deptno = d.deptno);
	+--------+----------+
	| ename  | loc      |
	+--------+----------+
	| KING   | NEW YORK |
	| BLAKE  | CHICAGO  |
	| CLARK  | NEW YORK |
	| JONES  | DALLAS   |
	| MARTIN | CHICAGO  |
	| ALLEN  | CHICAGO  |
	| TURNER | CHICAGO  |
	| JAMES  | CHICAGO  |
	| WARD   | CHICAGO  |
	| FORD   | DALLAS   |
	| SMITH  | DALLAS   |
	| SCOTT  | DALLAS   |
	| ADAMS  | DALLAS   |
	| MILLER | NEW YORK |
	| NULL   | BOSTON   |
	+--------+----------+
	15 rows in set (0.03 sec)



문제 145. 아래의 오라클의 full outer join 을 MySQL에서 구현하시오 !

------------------------------------------
insert into emp(empno, ename, sal, deptno)
  values (2929, 'jack', 4500, 70);
------------------------------------------

	SQL> select e.ename, d.loc 
	       from emp e full outer join dept d
	       on (e.deptno = d.deptno);
	
	mysql> select e.ename, d.loc
	    ->   from emp e left outer join dept d
	    ->   on (e.deptno = d.deptno)
	    -> union
	    -> select e.ename, d.loc
	    ->   from emp e right outer join dept d
	    ->   on (e.deptno = d.deptno);
	+--------+----------+
	| ename  | loc      |
	+--------+----------+
	| KING   | NEW YORK |
	| BLAKE  | CHICAGO  |
	| CLARK  | NEW YORK |
	| JONES  | DALLAS   |
	| MARTIN | CHICAGO  |
	| ALLEN  | CHICAGO  |
	| TURNER | CHICAGO  |
	| JAMES  | CHICAGO  |
	| WARD   | CHICAGO  |
	| FORD   | DALLAS   |
	| SMITH  | DALLAS   |
	| SCOTT  | DALLAS   |
	| ADAMS  | DALLAS   |
	| MILLER | NEW YORK |
	| jack   | NULL     |
	| NULL   | BOSTON   |
	+--------+----------+
	16 rows in set (0.00 sec)



 * 점심시간 문제

문제 146. (서브쿼리) JONES의 월급보다 더 많은 월급을 받는 사원들의 이름과 월급을 출력하시오 !

	mysql> select ename, sal
	    ->   from emp
	    ->   where sal > (select sal from emp where ename = 'JONES');
	+-------+------+
	| ename | sal  |
	+-------+------+
	| KING  | 5000 |
	| FORD  | 3000 |
	| SCOTT | 3000 |
	| jack  | 4500 |
	+-------+------+
	4 rows in set (0.00 sec)



문제 147. SCOOTT의 월급을 0으로 변경하시오 !

	mysql> update emp set sal = 0 where ename = 'scott';
	Query OK, 1 row affected (0.11 sec)
	Rows matched: 1  Changed: 1  Warnings: 0
	
	mysql> rollback;
	Query OK, 0 rows affected (0.00 sec)
	
	mysql> select * from emp;
	+-------+--------+-----------+------+------------+------+------+--------+
	| empNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL  | COMM | deptNO |
	+-------+--------+-----------+------+------------+------+------+--------+
	|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000 | NULL |     10 |
	|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850 | NULL |     30 |
	|  7782 | CLARK  | MANAGER   | 7839 | 1981-05-09 | 2450 | NULL |     10 |
	|  7566 | JONES  | MANAGER   | 7839 | 1981-04-01 | 2975 | NULL |     20 |
	|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-10 | 1250 | 1400 |     30 |
	|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-11 | 1600 |  300 |     30 |
	|  7844 | TURNER | SALESMAN  | 7698 | 1981-08-21 | 1500 |    0 |     30 |
	|  7900 | JAMES  | CLERK     | 7698 | 1981-12-11 |  950 | NULL |     30 |
	|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-23 | 1250 |  500 |     30 |
	|  7902 | FORD   | ANALYST   | 7566 | 1981-12-11 | 3000 | NULL |     20 |
	|  7369 | SMITH  | CLERK     | 7902 | 1980-12-09 |  800 | NULL |     20 |
	|  7788 | SCOTT  | ANALYST   | 7566 | 1982-12-22 |    0 | NULL |     20 |
	|  7876 | ADAMS  | CLERK     | 7788 | 1983-01-15 | 1100 | NULL |     20 |
	|  7934 | MILLER | CLERK     | 7782 | 1982-01-11 | 1300 | NULL |     10 |
	|  2929 | jack   | NULL      | NULL | NULL       | 4500 | NULL |     70 |
	+-------+--------+-----------+------+------------+------+------+--------+
	15 rows in set (0.00 sec)


	
	※ 자동 커밋이 default가 켜있기 때문에 rollback이 안된다.

	mysql> select @@autocommit;
	+--------------+
	| @@autocommit |
	+--------------+
	|            1 |
	+--------------+
	1 row in set (0.02 sec)
	
	mysql> set autocommit = 0;
	Query OK, 0 rows affected (0.00 sec)
	
	mysql> select @@autocommit;
	+--------------+
	| @@autocommit |
	+--------------+
	|            0 |
	+--------------+
	1 row in set (0.00 sec)



문제 148. 사원 테이블을 전체 delete 하시오 그리고 rollback되는지 확인하시오 !

	mysql> delete from emp;
	Query OK, 15 rows affected (0.00 sec)
	
	mysql> rollback;
	Query OK, 0 rows affected (0.00 sec)
	
	mysql> select * from emp;
	+-------+--------+-----------+------+------------+------+------+--------+
	| empNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL  | COMM | deptNO |
	+-------+--------+-----------+------+------------+------+------+--------+
	|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000 | NULL |     10 |
	|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850 | NULL |     30 |
	|  7782 | CLARK  | MANAGER   | 7839 | 1981-05-09 | 2450 | NULL |     10 |
	|  7566 | JONES  | MANAGER   | 7839 | 1981-04-01 | 2975 | NULL |     20 |
	|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-10 | 1250 | 1400 |     30 |
	|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-11 | 1600 |  300 |     30 |
	|  7844 | TURNER | SALESMAN  | 7698 | 1981-08-21 | 1500 |    0 |     30 |
	|  7900 | JAMES  | CLERK     | 7698 | 1981-12-11 |  950 | NULL |     30 |
	|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-23 | 1250 |  500 |     30 |
	|  7902 | FORD   | ANALYST   | 7566 | 1981-12-11 | 3000 | NULL |     20 |
	|  7369 | SMITH  | CLERK     | 7902 | 1980-12-09 |  800 | NULL |     20 |
	|  7788 | SCOTT  | ANALYST   | 7566 | 1982-12-22 |    0 | NULL |     20 |
	|  7876 | ADAMS  | CLERK     | 7788 | 1983-01-15 | 1100 | NULL |     20 |
	|  7934 | MILLER | CLERK     | 7782 | 1982-01-11 | 1300 | NULL |     10 |
	|  2929 | jack   | NULL      | NULL | NULL       | 4500 | NULL |     70 |
	+-------+--------+-----------+------+------------+------+------+--------+
	15 rows in set (0.00 sec)



문제 149. dept 테이블 생성 스크립트를 이용해서 dept2 테이블을 생성하고 dept2 테이블을 select한 후에 rollback을 하면
	  dept2 테이블이 어떻게 되는지 확인해 보시오 !

--------------------------------------------------------
CREATE TABLE dept2
(deptNO int,
DNAME VARCHAR(14),
LOC VARCHAR(13) );

INSERT INTO dept2 VALUES (10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO dept2 VALUES (20, 'RESEARCH', 'DALLAS');
INSERT INTO dept2 VALUES (30, 'SALES', 'CHICAGO');
INSERT INTO dept2 VALUES (40, 'OPERATIONS', 'BOSTON');
--------------------------------------------------------

	mysql> select * from dept2;
	+--------+------------+----------+
	| deptNO | DNAME      | LOC      |
	+--------+------------+----------+
	|     10 | ACCOUNTING | NEW YORK |
	|     20 | RESEARCH   | DALLAS   |
	|     30 | SALES      | CHICAGO  |
	|     40 | OPERATIONS | BOSTON   |
	+--------+------------+----------+
	4 rows in set (0.00 sec)
	
	mysql> rollback;
	Query OK, 0 rows affected (0.00 sec)
	
	mysql> select * from dept2;
	Empty set (0.00 sec)










■ MySQL에서 DDL문
	- 오라클과의 차이점
		external table의 관리가 오라클과 다르다.


	mysql> CREATE TABLE emp2 (
	    -> EMPNO int NOT NULL,
	    -> ENAME VARCHAR(10),
	    -> JOB VARCHAR(9),
	    -> MGR int,
	    -> HIREDATE DATE,
	    -> SAL int,
	    -> COMM int,
	    -> DEPTNO int );
	Query OK, 0 rows affected (0.04 sec)
	
	mysql> load  data  local infile '/home/oracle/emp2.csv'
	    ->  into  table  emp2  fields  terminated  by ',';
	Query OK, 15 rows affected, 8 warnings (0.00 sec)
	Records: 15  Deleted: 0  Skipped: 0  Warnings: 8
	
	mysql> select * from emp2;
	+-------+--------+-----------+------+------------+------+------+--------+
	| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL  | COMM | DEPTNO |
	+-------+--------+-----------+------+------------+------+------+--------+
	|  7839 | KING   | PRESIDENT |    0 | 1981-11-17 | 5000 |    0 |     10 |
	|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850 |    0 |     30 |
	|  7782 | CLARK  | MANAGER   | 7839 | 1981-05-09 | 2450 |    0 |     10 |
	|  7566 | JONES  | MANAGER   | 7839 | 1981-04-01 | 2975 |    0 |     20 |
	|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-10 | 1250 | 1400 |     30 |
	|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-11 | 1600 |  300 |     30 |
	|  7844 | TURNER | SALESMAN  | 7698 | 1981-08-21 | 1500 |    0 |     30 |
	|  7900 | JAMES  | CLERK     | 7698 | 1981-12-11 |  950 |    0 |     30 |
	|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-23 | 1250 |  500 |     30 |
	|  7902 | FORD   | ANALYST   | 7566 | 1981-12-11 | 3000 |    0 |     20 |
	|  7369 | SMITH  | CLERK     | 7902 | 1980-12-09 |  800 |    0 |     20 |
	|  7788 | SCOTT  | ANALYST   | 7566 | 1982-12-22 | 3000 |    0 |     20 |
	|  7876 | ADAMS  | CLERK     | 7788 | 1983-01-15 | 1100 |    0 |     20 |
	|  7934 | MILLER | CLERK     | 7782 | 1982-01-11 | 1300 |    0 |     10 |
	|     0 | NULL   | NULL      | NULL | NULL       | NULL | NULL |   NULL |
	+-------+--------+-----------+------+------------+------+------+--------+
	15 rows in set (0.00 sec)














■ sqoop

★ 스쿱
	- 오라클과 hive와의 데이터 연동
	- 오라클의 emp테이블을 hive로 바로 로드할 수 있다.





* 스쿱 설치 과정 

	  1. 스쿱설치 파일을 올린다.
	
		    sqoop-1.4.6.bin__hadoop-1.0.0.tar.gz
	
	  2. 스쿱설치 파일의 압축을 푼다.
	
		    # cd  /media/sf_Share
		    # chown  -R  oracle:oinstall sqoop-1.4.6.bin__hadoop- 1.0.0.tar.gz
		
		    # cp  sqoop-1.4.6.bin__hadoop-1.0.0.tar.gz  /home/oracle/
		
		    # su - oracle
		
		    $ tar xvzf  sqoop-1.4.6.bin__hadoop-1.0.0.tar.gz
	  
	  3. ojdbc6.jar 파일을 sqoop 라이브러리로 이동한다.
	
		    # cd /media/sf_Share
		    # chown -R oracle:oinstall ojdbc6.zip
		    # cp ojdbc6.zip  /home/oracle/
		    # su - oracle
		    $ unzip  ojdbc6.zip
		    $ ls -l ojdbc6.jar 
		    $ mv sqoop-1.4.6.bin__hadoop-1.0.0 sqoop
		    $ cp /home/oracle/ojdbc6.jar  /home/oracle/sqoop/lib/
	    
	  4. 스쿱 디렉토리의 bin 디렉토리로 가서 스쿱을 실행한다.
	  
		    $ cd /home/oracle
		    $ cd sqoop
		    $ cd bin
		    $ ./sqoop 
	
	         4개의 경고가 뜨면 정상 
	
	  5. .bash_profile 에 sqoop 홈 디렉토리를 지정한다.
	
		    $ cd /home/oracle
		    $ vi .bash_profile
	
		    export  SQOOP_HOME=/home/oracle/sqoop
		    export  PATH=$SQOOP_HOME/bin:$PATH 
	
		    $ . .bash_profile
		


		★ hive가 정상인지 확인한다. 
		
			[orcl:~]$ start-all.sh
			
			[orcl:~]$ jps
			6873 TaskTracker
			6967 Jps
			6344 NameNode
			6617 SecondaryNameNode
			6731 JobTracker
			6475 DataNode
			
			[orcl:~]$ hive
			
			hive>



		★ 오라클이 정상인지 확인한다.
		
			[orcl:~]$ sqlplus scott/tiger
		
			hive> drop table dept;



	  6. 오라클의 dept 테이블을 hive 로 로드한다.

		1. 오라클에서 hive로 데이터 이행을 위한 스크립트를 준비한다.
			$ vi table_import.sh

			#!/bin/bash
			
			oracle_table=`echo $3 | tr '[a-z]' '[A-Z]'`
			hadoop_table=`echo $3 | tr '[A-Z]' '[a-z]'`
			
			sqoop import --username $1 \
			--password $2 \
			--connect jdbc:oracle:thin:@localhost:1521:orcl \
			--table $oracle_table \
			--hive-import \
			--hive-table $hadoop_table \
			--hive-overwrite \
			-m 1
			
			[orcl:~]$ sh table_import.sh scott tiger DEPT
					:
					:
			19/01/04 16:00:12 INFO hive.HiveImport: OK
			19/01/04 16:00:12 INFO hive.HiveImport: Time taken: 0.498 seconds
			19/01/04 16:00:12 INFO hive.HiveImport: Hive import complete.

			hive> select * from dept;
			OK
			10.0    ACCOUNTING      NEW YORK
			20.0    RESEARCH        DALLAS
			30.0    SALES   CHICAGO
			40.0    OPERATIONS      BOSTON
			Time taken: 3.869 seconds, Fetched: 4 row(s)



문제 150. hive에서 emp 테이블을 drop하고 오라클의 emp를 hive로 이행하시오 !

	hive> drop table emp;

	[orcl:~]$ sh table_import.sh scott tiger emp
				:
				:
	19/01/04 16:05:46 INFO hive.HiveImport: OK
	19/01/04 16:05:46 INFO hive.HiveImport: Time taken: 0.427 seconds
	19/01/04 16:05:46 INFO hive.HiveImport: Hive import complete.

	hive> select * from emp;
	OK
	7369.0  SMITH   CLERK   7902.0  1980-12-17 00:00:00.0   800.0   NULL    20.0
	7499.0  ALLEN   SALESMAN        7698.0  1981-02-20 00:00:00.0   1600.0  300.0   30.0
	7521.0  WARD    SALESMAN        7698.0  1981-02-22 00:00:00.0   1250.0  500.0   30.0
	7566.0  JONES   MANAGER 7839.0  1981-04-02 00:00:00.0   2975.0  NULL    20.0
	7654.0  MARTIN  SALESMAN        7698.0  1981-09-28 00:00:00.0   1250.0  1400.0  30.0
	7698.0  BLAKE   MANAGER 7839.0  1981-05-01 00:00:00.0   2850.0  NULL    30.0
	7782.0  CLARK   MANAGER 7839.0  1981-06-09 00:00:00.0   2450.0  NULL    10.0
	7788.0  SCOTT   ANALYST 7566.0  1987-04-19 00:00:00.0   3000.0  NULL    20.0
	7839.0  KING    PRESIDENT       NULL    1981-11-17 00:00:00.0   5000.0  NULL    10.0
	7844.0  TURNER  SALESMAN        7698.0  1981-09-08 00:00:00.0   1500.0  0.0     30.0
	7876.0  ADAMS   CLERK   7788.0  1987-05-23 00:00:00.0   1100.0  NULL    20.0
	7900.0  JAMES   CLERK   7698.0  1981-12-03 00:00:00.0   950.0   NULL    30.0
	7902.0  FORD    ANALYST 7566.0  1981-12-03 00:00:00.0   3000.0  NULL    20.0
	7934.0  MILLER  CLERK   7782.0  1982-01-23 00:00:00.0   1300.0  NULL    10.0
	Time taken: 4.03 seconds, Fetched: 14 row(s)



















	SQL	--> 	파이썬	-->	리눅스	-->	하둡	-->	딥러닝(파이썬)	-->	R

			프로그래밍     --     시스템 엔지니어    --    프로그래밍     --      이론







■ 10. 맵리듀스를 java로 수행하기 (실습_02.Java 를 이용한 HDFS 입출력.txt 참고)

		[orcl:~]$ start-all.sh

		[orcl:~]$ jps
		6039 TaskTracker
		5647 DataNode
		5782 SecondaryNameNode
		6148 Jps
		5881 JobTracker
		5516 NameNode


	1. hadoop 홈디렉토리에 자바 실행 파일인 jar 파일의 위치가 어디인지 설정하는 환경설정을 한다.


	2. 하둡 홈디렉토리 밑에 labs 라는 디렉토리를 만들고 거기에  SingleFileWriteRead.java 파일을 생성한다.
										↓
							텍스트 파일 한개를 하둡 파일 시스템에 올리는 자바 코드


	3. 두개의 텍스트 파일을 하나로 합쳐서 하둡 파일 시스템에 올리기 위해 PutMerge.java라는 파일을 생성한다.


	4. 자바로 WordCount를 수행한다.
		      ↓
		겨울왕국 대본의 단어와 단어의 갯수를 출력한다.
			SQL    --> regexpress_count 함수로 수행
			파이썬 --> len 함수로 수행
			리눅스 --> wc  함수로 수행 
			하둡   --> 자바코드로 수행
			R      --> ?















 노트정리 제출 : NCS_하둡_수업정리_문제150개_정성호


































